{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _binding = require(\"../binding\");\n\nvar _binding2 = _interopRequireDefault(_binding);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar renameVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {\n    var node = _ref.node;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n  \"AssignmentExpression|Declaration\": function AssignmentExpressionDeclaration(path, state) {\n    var ids = path.getOuterBindingIdentifiers();\n\n    for (var name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\n\nvar Renamer = function () {\n  function Renamer(binding, oldName, newName) {\n    (0, _classCallCheck3.default)(this, Renamer);\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  Renamer.prototype.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {\n    var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;\n    if (!exportDeclar) return;\n    var isDefault = exportDeclar.isExportDefaultDeclaration();\n\n    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {\n      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier(\"default\");\n    }\n\n    var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();\n    var specifiers = [];\n\n    for (var name in bindingIdentifiers) {\n      var localName = name === this.oldName ? this.newName : name;\n      var exportedName = isDefault ? \"default\" : name;\n      specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));\n    }\n\n    if (specifiers.length) {\n      var aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n\n      if (parentDeclar.isFunctionDeclaration()) {\n        aliasDeclar._blockHoist = 3;\n      }\n\n      exportDeclar.insertAfter(aliasDeclar);\n      exportDeclar.replaceWith(parentDeclar.node);\n    }\n  };\n\n  Renamer.prototype.rename = function rename(block) {\n    var binding = this.binding,\n        oldName = this.oldName,\n        newName = this.newName;\n    var scope = binding.scope,\n        path = binding.path;\n    var parentDeclar = path.find(function (path) {\n      return path.isDeclaration() || path.isFunctionExpression();\n    });\n\n    if (parentDeclar) {\n      this.maybeConvertFromExportDeclaration(parentDeclar);\n    }\n\n    scope.traverse(block || scope.block, renameVisitor, this);\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n  };\n\n  return Renamer;\n}();\n\nexports.default = Renamer;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}